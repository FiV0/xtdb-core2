= SQL Time Queries

https://github.com/xtdb/core2-playground/blob/main/bitemporal/snodgrass-99.sql[Some examples from the `core2-playground` repo].


[#enhancedsql2011]
== Enhanced SQL:2011

XTDB defaults to SQL:2011 behaviour but alternative temporal defaults are offered.
The following command will switch XTDB's Application Time semantics to "as of now",
which will feel more natural to most users.

[source,sql]
----
SET APPLICATION_TIME_DEFAULTS TO AS_OF_NOW;
----

With "as of now" Application Time semantics, the following inserted record is only visible
when time-travelling (`FOR APPLICATION_TIME AS OF`) to the year 2027 or when viewing the
entire timeline at once (`FOR ALL APPLICATION_TIME`):

[source,sql]
----
INSERT INTO posts (id, user_id, text, application_time_start)
  VALUES (9012, 5678, 'Happy 2027!', DATE '2027-01-01');

SELECT posts.text FROM posts
  FOR APPLICATION_TIME AS OF DATE '2027-01-02';

-- data from 2027 is not visible by default
SELECT posts.text FROM posts;

-- data from 2027 becomes visible when viewing the entire timeline
SELECT posts.text FROM posts FOR ALL APPLICATION_TIME;
----


[#isosql2011]
== ISO SQL:2011

Although XTDB defaults to SQL:2011 behaviour, you can explicitly set this behaviour
to switch away from the "as of now" defaults, if you've set them:

[source,sql]
----
SET APPLICATION_TIME_DEFAULTS TO ISO_STANDARD;
----

When XTDB is in ISO Standard mode, queries will return records visible to all of Application Time:

[source,sql]
----
INSERT INTO posts (id, user_id, text, application_time_start)
  VALUES (9012, 5678, 'Happy 2027!', DATE '2027-01-01');

-- data from 2027 is visible by default
SELECT posts.text, posts.application_time_start FROM posts;
----

While using ISO Standard mode, it is often helpful to orient oneself
by querying all 4 built-in time columns:

[source,sql]
----
SELECT posts.text,
       posts.system_time_start,
       posts.system_time_end,
       posts.application_time_start,
       posts.application_time_end FROM posts;
----


== Time Columns

* `SYSTEM_TIME`
* `APPLICATION_TIME`

== Time Travel

* `FOR SYSTEM_TIME AS OF`
* `FOR APPLICATION_TIME AS OF`

== Ignoring Time

* `FOR ALL SYSTEM_TIME`
* `FOR ALL APPLICATION_TIME`

== Periods

Intentionally duplicated from Data Types doc:

* `PERIOD(x,y)`

== Temporal Predicates

* `CONTAINS, OVERLAPS, EQUALS, PRECEDES, SUCCEEDS, IMMEDIATELY PRECEDES, and IMMEDIATELY SUCCEEDS`

== Automatic (Application) Time Period Splitting

* Probably just mention that this happens on `UPDATE` / `DELETE`?


[#inspectthetimeline]
== Inspect The Timeline

Whether you are in `AS_OF_NOW` or `ISO_STANDARD` mode, you can inspect the entire timeline.

To inspect all of System Time:

[source,sql]
----
SELECT posts.text,
       posts.system_time_start,
       posts.system_time_end,
       posts.application_time_start,
       posts.application_time_end
       FROM posts
       FOR ALL SYSTEM_TIME;
----

To inspect all of Application Time:

[source,sql]
----
SELECT posts.text,
       posts.system_time_start,
       posts.system_time_end,
       posts.application_time_start,
       posts.application_time_end
       FROM posts
       FOR ALL APPLICATION_TIME;
----

These two clauses can be combined to inspect the entire time plane (both timelines).


== Temporal Data Patterns

=== Move a record into the past/future

To retroactively "move" a record into the past or future, use the "upsert" functionality of the `INSERT` statement:

[source,sql]
----
INSERT INTO products (id,name,application_time_start)
  VALUES (1,'iPhone',DATE '2009-01-01');
SELECT products.name,products.application_time_start
  FROM products; -- returns 2009

INSERT INTO products (id,name,application_time_start)
  VALUES (1,'iPhone',DATE '2007-06-29');
SELECT products.name,products.application_time_start
  FROM products; -- returns correct 2007 date
----

It is not possible to use an `UPDATE` statement to change a record's `APPLICATION_TIME`.

=== Change a record for a portion of (its) time

`UPDATE ... FOR PORTION OF APPLICATION_TIME` can be used for exactly this purpose:

[source,sql]
----
INSERT INTO employee (id, name, title, application_time_start)
  VALUES (4, 'Deepa', 'Developer', DATE '2013-07-31');

UPDATE employee FOR PORTION OF APPLICATION_TIME
  FROM DATE '2018-01-01' TO DATE '2021-01-01'
  SET title = 'CEO'
  WHERE employee.id = 4;

SELECT employee.title, employee.application_time_start
  FROM employee FOR ALL APPLICATION_TIME
  WHERE employee.id=4;
----
